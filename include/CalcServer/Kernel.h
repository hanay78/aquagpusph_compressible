/*
 *  This file is part of AQUAgpusph, a free CFD program based on SPH.
 *  Copyright (C) 2012  Jose Luis Cercos Pita <jl.cercos@upm.es>
 *
 *  AQUAgpusph is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AQUAgpusph is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with AQUAgpusph.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @file
 * @brief OpenCL kernel kernel based tool.
 * (see Aqua::CalcServer::Kernel for details)
 */

#ifndef KERNEL_H_INCLUDED
#define KERNEL_H_INCLUDED

#include <sphPrerequisites.h>

#include <vector>
#if __APPLE__
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif
#include <CalcServer/Tool.h>

namespace Aqua {
namespace CalcServer {

/** @class Kernel Kernel.h CalcServer/Kernel.h
 * @brief A tool consisting in an OpenCL kernel execution. The variables used
 * in the OpenCL kernel are automatically detected.
 */
class Kernel : public Aqua::CalcServer::Tool
{
  public:
	/** Constructor.
	 * @param tool_name Tool name.
	 * @param kernel_path Kernel path.
	 * @param n Number of threads to launch. An empty string to autocompute it
	 * from the length of the output array variables
	 * @param once Run this tool just once. Useful to make initializations.
	 */
	Kernel(const std::string tool_name,
	       const std::string kernel_path,
	       const std::string entry_point = "entry",
	       const std::string n = "",
	       bool once = false);

	/** Destructor
	 */
	virtual ~Kernel();

	/** Initialize the tool.
	 * @return false if all gone right, true otherwise.
	 */
	void setup();

	/** Get the kernel file path.
	 * @return Tool kernel file path.
	 */
	const std::string path() { return (const std::string)_path; }

	/** Get the work group size
	 * @return Work group size
	 */
	size_t workGroupSize() const { return _work_group_size; }

	/** Get the work group size
	 * @return Work group size
	 */
	size_t globalWorkSize() const { return _global_work_size; }

	/** @brief Set the variables to the OpenCL kernel.
	 * @param with_arrays false to skip the array variables, which are never
	 * changing value (memory address)
	 */
	void setVariables(bool with_arrays = false);

	/** @brief Get the user event generated by this tool to mark when is
	 * finished
	 *
	 * @return The event
	 * @note This event will be the same than
	 * Aqua::CalcServer::Tool::getEvent(), however we need it just in case the
	 * callback is executed before Aqua::CalcServer::Tool had time to store it
	 * (race condition)
	 */
	inline cl_event getUserEvent() const { return _user_event; }

  protected:
	/** Execute the tool
	 * @param events List of events that shall be waited before safe execution
	 * @return OpenCL event to be waited before accessing the dependencies
	 */
	cl_event _execute(const std::vector<cl_event> events);

	/** Compile the OpenCL program
	 * @param entry_point Program entry point method.
	 * @param flags Compiling additional flags.
	 * @param header Header to be append at the start of the source code.
	 * @return false if all gone right, true otherwise.
	 */
	void make(const std::string entry_point = "entry",
	          const std::string flags = "",
	          const std::string header = "");

	/** Compute the variables required by the program
	 * @param entry_point Program entry point method.
	 * @return false if all gone right, true otherwise.
	 */
	void variables(const std::string entry_point = "main");

	/** Compute the global work size
	 */
	void computeGlobalWorkSize();

  private:
	/// Kernel path
	std::string _path;

	/// Kernel entry point
	std::string _entry_point;

	/// Number of threads expression
	std::string _n;

	/// OpenCL kernel
	cl_kernel _kernel;

	/// work group size
	size_t _work_group_size;

	/// global work size
	size_t _global_work_size;

	/// List of dependencies, in the same order they have as kernel arguments
	std::vector<InputOutput::Variable*> _vars;

	/// List of scalar dependencies
	std::vector<InputOutput::Variable*> _scalar_vars;

	/// Transactional event to know when the kernel args have been set
	cl_event _user_event;
};

}
} // namespace

#endif // KERNEL_H_INCLUDED
